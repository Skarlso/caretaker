// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"sync"

	"github.com/shurcooL/githubv4"
	"github.com/skarlso/caretaker/pkg/client"
)

type FakeClient struct {
	AddLabelStub        func(context.Context, string, githubv4.ID) error
	addLabelMutex       sync.RWMutex
	addLabelArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 githubv4.ID
	}
	addLabelReturns struct {
		result1 error
	}
	addLabelReturnsOnCall map[int]struct {
		result1 error
	}
	AddReactionStub        func(context.Context, githubv4.ID, githubv4.ReactionContent) error
	addReactionMutex       sync.RWMutex
	addReactionArgsForCall []struct {
		arg1 context.Context
		arg2 githubv4.ID
		arg3 githubv4.ReactionContent
	}
	addReactionReturns struct {
		result1 error
	}
	addReactionReturnsOnCall map[int]struct {
		result1 error
	}
	AssignIssueToProjectStub        func(context.Context, int, int) error
	assignIssueToProjectMutex       sync.RWMutex
	assignIssueToProjectArgsForCall []struct {
		arg1 context.Context
		arg2 int
		arg3 int
	}
	assignIssueToProjectReturns struct {
		result1 error
	}
	assignIssueToProjectReturnsOnCall map[int]struct {
		result1 error
	}
	AssignUserToAssignableStub        func(context.Context, githubv4.ID, githubv4.ID) error
	assignUserToAssignableMutex       sync.RWMutex
	assignUserToAssignableArgsForCall []struct {
		arg1 context.Context
		arg2 githubv4.ID
		arg3 githubv4.ID
	}
	assignUserToAssignableReturns struct {
		result1 error
	}
	assignUserToAssignableReturnsOnCall map[int]struct {
		result1 error
	}
	IssueStub        func(context.Context, int) (client.Issue, error)
	issueMutex       sync.RWMutex
	issueArgsForCall []struct {
		arg1 context.Context
		arg2 int
	}
	issueReturns struct {
		result1 client.Issue
		result2 error
	}
	issueReturnsOnCall map[int]struct {
		result1 client.Issue
		result2 error
	}
	LeaveCommentStub        func(context.Context, githubv4.ID, string) error
	leaveCommentMutex       sync.RWMutex
	leaveCommentArgsForCall []struct {
		arg1 context.Context
		arg2 githubv4.ID
		arg3 string
	}
	leaveCommentReturns struct {
		result1 error
	}
	leaveCommentReturnsOnCall map[int]struct {
		result1 error
	}
	ProjectItemsStub        func(context.Context, int) ([]client.ProjectV2ItemWithIssueContent, error)
	projectItemsMutex       sync.RWMutex
	projectItemsArgsForCall []struct {
		arg1 context.Context
		arg2 int
	}
	projectItemsReturns struct {
		result1 []client.ProjectV2ItemWithIssueContent
		result2 error
	}
	projectItemsReturnsOnCall map[int]struct {
		result1 []client.ProjectV2ItemWithIssueContent
		result2 error
	}
	PullRequestStub        func(context.Context, int) (client.PullRequest, error)
	pullRequestMutex       sync.RWMutex
	pullRequestArgsForCall []struct {
		arg1 context.Context
		arg2 int
	}
	pullRequestReturns struct {
		result1 client.PullRequest
		result2 error
	}
	pullRequestReturnsOnCall map[int]struct {
		result1 client.PullRequest
		result2 error
	}
	PullRequestsStub        func(context.Context) ([]client.PullRequest, error)
	pullRequestsMutex       sync.RWMutex
	pullRequestsArgsForCall []struct {
		arg1 context.Context
	}
	pullRequestsReturns struct {
		result1 []client.PullRequest
		result2 error
	}
	pullRequestsReturnsOnCall map[int]struct {
		result1 []client.PullRequest
		result2 error
	}
	RemoveLabelStub        func(context.Context, string, githubv4.ID) error
	removeLabelMutex       sync.RWMutex
	removeLabelArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 githubv4.ID
	}
	removeLabelReturns struct {
		result1 error
	}
	removeLabelReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateIssueStatusStub        func(context.Context, client.Issue, githubv4.String, int) (bool, error)
	updateIssueStatusMutex       sync.RWMutex
	updateIssueStatusArgsForCall []struct {
		arg1 context.Context
		arg2 client.Issue
		arg3 githubv4.String
		arg4 int
	}
	updateIssueStatusReturns struct {
		result1 bool
		result2 error
	}
	updateIssueStatusReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	UserStub        func(context.Context, string) (client.User, error)
	userMutex       sync.RWMutex
	userArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	userReturns struct {
		result1 client.User
		result2 error
	}
	userReturnsOnCall map[int]struct {
		result1 client.User
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) AddLabel(arg1 context.Context, arg2 string, arg3 githubv4.ID) error {
	fake.addLabelMutex.Lock()
	ret, specificReturn := fake.addLabelReturnsOnCall[len(fake.addLabelArgsForCall)]
	fake.addLabelArgsForCall = append(fake.addLabelArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 githubv4.ID
	}{arg1, arg2, arg3})
	stub := fake.AddLabelStub
	fakeReturns := fake.addLabelReturns
	fake.recordInvocation("AddLabel", []interface{}{arg1, arg2, arg3})
	fake.addLabelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) AddLabelCallCount() int {
	fake.addLabelMutex.RLock()
	defer fake.addLabelMutex.RUnlock()
	return len(fake.addLabelArgsForCall)
}

func (fake *FakeClient) AddLabelCalls(stub func(context.Context, string, githubv4.ID) error) {
	fake.addLabelMutex.Lock()
	defer fake.addLabelMutex.Unlock()
	fake.AddLabelStub = stub
}

func (fake *FakeClient) AddLabelArgsForCall(i int) (context.Context, string, githubv4.ID) {
	fake.addLabelMutex.RLock()
	defer fake.addLabelMutex.RUnlock()
	argsForCall := fake.addLabelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) AddLabelReturns(result1 error) {
	fake.addLabelMutex.Lock()
	defer fake.addLabelMutex.Unlock()
	fake.AddLabelStub = nil
	fake.addLabelReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) AddLabelReturnsOnCall(i int, result1 error) {
	fake.addLabelMutex.Lock()
	defer fake.addLabelMutex.Unlock()
	fake.AddLabelStub = nil
	if fake.addLabelReturnsOnCall == nil {
		fake.addLabelReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addLabelReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) AddReaction(arg1 context.Context, arg2 githubv4.ID, arg3 githubv4.ReactionContent) error {
	fake.addReactionMutex.Lock()
	ret, specificReturn := fake.addReactionReturnsOnCall[len(fake.addReactionArgsForCall)]
	fake.addReactionArgsForCall = append(fake.addReactionArgsForCall, struct {
		arg1 context.Context
		arg2 githubv4.ID
		arg3 githubv4.ReactionContent
	}{arg1, arg2, arg3})
	stub := fake.AddReactionStub
	fakeReturns := fake.addReactionReturns
	fake.recordInvocation("AddReaction", []interface{}{arg1, arg2, arg3})
	fake.addReactionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) AddReactionCallCount() int {
	fake.addReactionMutex.RLock()
	defer fake.addReactionMutex.RUnlock()
	return len(fake.addReactionArgsForCall)
}

func (fake *FakeClient) AddReactionCalls(stub func(context.Context, githubv4.ID, githubv4.ReactionContent) error) {
	fake.addReactionMutex.Lock()
	defer fake.addReactionMutex.Unlock()
	fake.AddReactionStub = stub
}

func (fake *FakeClient) AddReactionArgsForCall(i int) (context.Context, githubv4.ID, githubv4.ReactionContent) {
	fake.addReactionMutex.RLock()
	defer fake.addReactionMutex.RUnlock()
	argsForCall := fake.addReactionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) AddReactionReturns(result1 error) {
	fake.addReactionMutex.Lock()
	defer fake.addReactionMutex.Unlock()
	fake.AddReactionStub = nil
	fake.addReactionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) AddReactionReturnsOnCall(i int, result1 error) {
	fake.addReactionMutex.Lock()
	defer fake.addReactionMutex.Unlock()
	fake.AddReactionStub = nil
	if fake.addReactionReturnsOnCall == nil {
		fake.addReactionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addReactionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) AssignIssueToProject(arg1 context.Context, arg2 int, arg3 int) error {
	fake.assignIssueToProjectMutex.Lock()
	ret, specificReturn := fake.assignIssueToProjectReturnsOnCall[len(fake.assignIssueToProjectArgsForCall)]
	fake.assignIssueToProjectArgsForCall = append(fake.assignIssueToProjectArgsForCall, struct {
		arg1 context.Context
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.AssignIssueToProjectStub
	fakeReturns := fake.assignIssueToProjectReturns
	fake.recordInvocation("AssignIssueToProject", []interface{}{arg1, arg2, arg3})
	fake.assignIssueToProjectMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) AssignIssueToProjectCallCount() int {
	fake.assignIssueToProjectMutex.RLock()
	defer fake.assignIssueToProjectMutex.RUnlock()
	return len(fake.assignIssueToProjectArgsForCall)
}

func (fake *FakeClient) AssignIssueToProjectCalls(stub func(context.Context, int, int) error) {
	fake.assignIssueToProjectMutex.Lock()
	defer fake.assignIssueToProjectMutex.Unlock()
	fake.AssignIssueToProjectStub = stub
}

func (fake *FakeClient) AssignIssueToProjectArgsForCall(i int) (context.Context, int, int) {
	fake.assignIssueToProjectMutex.RLock()
	defer fake.assignIssueToProjectMutex.RUnlock()
	argsForCall := fake.assignIssueToProjectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) AssignIssueToProjectReturns(result1 error) {
	fake.assignIssueToProjectMutex.Lock()
	defer fake.assignIssueToProjectMutex.Unlock()
	fake.AssignIssueToProjectStub = nil
	fake.assignIssueToProjectReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) AssignIssueToProjectReturnsOnCall(i int, result1 error) {
	fake.assignIssueToProjectMutex.Lock()
	defer fake.assignIssueToProjectMutex.Unlock()
	fake.AssignIssueToProjectStub = nil
	if fake.assignIssueToProjectReturnsOnCall == nil {
		fake.assignIssueToProjectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.assignIssueToProjectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) AssignUserToAssignable(arg1 context.Context, arg2 githubv4.ID, arg3 githubv4.ID) error {
	fake.assignUserToAssignableMutex.Lock()
	ret, specificReturn := fake.assignUserToAssignableReturnsOnCall[len(fake.assignUserToAssignableArgsForCall)]
	fake.assignUserToAssignableArgsForCall = append(fake.assignUserToAssignableArgsForCall, struct {
		arg1 context.Context
		arg2 githubv4.ID
		arg3 githubv4.ID
	}{arg1, arg2, arg3})
	stub := fake.AssignUserToAssignableStub
	fakeReturns := fake.assignUserToAssignableReturns
	fake.recordInvocation("AssignUserToAssignable", []interface{}{arg1, arg2, arg3})
	fake.assignUserToAssignableMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) AssignUserToAssignableCallCount() int {
	fake.assignUserToAssignableMutex.RLock()
	defer fake.assignUserToAssignableMutex.RUnlock()
	return len(fake.assignUserToAssignableArgsForCall)
}

func (fake *FakeClient) AssignUserToAssignableCalls(stub func(context.Context, githubv4.ID, githubv4.ID) error) {
	fake.assignUserToAssignableMutex.Lock()
	defer fake.assignUserToAssignableMutex.Unlock()
	fake.AssignUserToAssignableStub = stub
}

func (fake *FakeClient) AssignUserToAssignableArgsForCall(i int) (context.Context, githubv4.ID, githubv4.ID) {
	fake.assignUserToAssignableMutex.RLock()
	defer fake.assignUserToAssignableMutex.RUnlock()
	argsForCall := fake.assignUserToAssignableArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) AssignUserToAssignableReturns(result1 error) {
	fake.assignUserToAssignableMutex.Lock()
	defer fake.assignUserToAssignableMutex.Unlock()
	fake.AssignUserToAssignableStub = nil
	fake.assignUserToAssignableReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) AssignUserToAssignableReturnsOnCall(i int, result1 error) {
	fake.assignUserToAssignableMutex.Lock()
	defer fake.assignUserToAssignableMutex.Unlock()
	fake.AssignUserToAssignableStub = nil
	if fake.assignUserToAssignableReturnsOnCall == nil {
		fake.assignUserToAssignableReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.assignUserToAssignableReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Issue(arg1 context.Context, arg2 int) (client.Issue, error) {
	fake.issueMutex.Lock()
	ret, specificReturn := fake.issueReturnsOnCall[len(fake.issueArgsForCall)]
	fake.issueArgsForCall = append(fake.issueArgsForCall, struct {
		arg1 context.Context
		arg2 int
	}{arg1, arg2})
	stub := fake.IssueStub
	fakeReturns := fake.issueReturns
	fake.recordInvocation("Issue", []interface{}{arg1, arg2})
	fake.issueMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) IssueCallCount() int {
	fake.issueMutex.RLock()
	defer fake.issueMutex.RUnlock()
	return len(fake.issueArgsForCall)
}

func (fake *FakeClient) IssueCalls(stub func(context.Context, int) (client.Issue, error)) {
	fake.issueMutex.Lock()
	defer fake.issueMutex.Unlock()
	fake.IssueStub = stub
}

func (fake *FakeClient) IssueArgsForCall(i int) (context.Context, int) {
	fake.issueMutex.RLock()
	defer fake.issueMutex.RUnlock()
	argsForCall := fake.issueArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) IssueReturns(result1 client.Issue, result2 error) {
	fake.issueMutex.Lock()
	defer fake.issueMutex.Unlock()
	fake.IssueStub = nil
	fake.issueReturns = struct {
		result1 client.Issue
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) IssueReturnsOnCall(i int, result1 client.Issue, result2 error) {
	fake.issueMutex.Lock()
	defer fake.issueMutex.Unlock()
	fake.IssueStub = nil
	if fake.issueReturnsOnCall == nil {
		fake.issueReturnsOnCall = make(map[int]struct {
			result1 client.Issue
			result2 error
		})
	}
	fake.issueReturnsOnCall[i] = struct {
		result1 client.Issue
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) LeaveComment(arg1 context.Context, arg2 githubv4.ID, arg3 string) error {
	fake.leaveCommentMutex.Lock()
	ret, specificReturn := fake.leaveCommentReturnsOnCall[len(fake.leaveCommentArgsForCall)]
	fake.leaveCommentArgsForCall = append(fake.leaveCommentArgsForCall, struct {
		arg1 context.Context
		arg2 githubv4.ID
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.LeaveCommentStub
	fakeReturns := fake.leaveCommentReturns
	fake.recordInvocation("LeaveComment", []interface{}{arg1, arg2, arg3})
	fake.leaveCommentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) LeaveCommentCallCount() int {
	fake.leaveCommentMutex.RLock()
	defer fake.leaveCommentMutex.RUnlock()
	return len(fake.leaveCommentArgsForCall)
}

func (fake *FakeClient) LeaveCommentCalls(stub func(context.Context, githubv4.ID, string) error) {
	fake.leaveCommentMutex.Lock()
	defer fake.leaveCommentMutex.Unlock()
	fake.LeaveCommentStub = stub
}

func (fake *FakeClient) LeaveCommentArgsForCall(i int) (context.Context, githubv4.ID, string) {
	fake.leaveCommentMutex.RLock()
	defer fake.leaveCommentMutex.RUnlock()
	argsForCall := fake.leaveCommentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) LeaveCommentReturns(result1 error) {
	fake.leaveCommentMutex.Lock()
	defer fake.leaveCommentMutex.Unlock()
	fake.LeaveCommentStub = nil
	fake.leaveCommentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) LeaveCommentReturnsOnCall(i int, result1 error) {
	fake.leaveCommentMutex.Lock()
	defer fake.leaveCommentMutex.Unlock()
	fake.LeaveCommentStub = nil
	if fake.leaveCommentReturnsOnCall == nil {
		fake.leaveCommentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.leaveCommentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ProjectItems(arg1 context.Context, arg2 int) ([]client.ProjectV2ItemWithIssueContent, error) {
	fake.projectItemsMutex.Lock()
	ret, specificReturn := fake.projectItemsReturnsOnCall[len(fake.projectItemsArgsForCall)]
	fake.projectItemsArgsForCall = append(fake.projectItemsArgsForCall, struct {
		arg1 context.Context
		arg2 int
	}{arg1, arg2})
	stub := fake.ProjectItemsStub
	fakeReturns := fake.projectItemsReturns
	fake.recordInvocation("ProjectItems", []interface{}{arg1, arg2})
	fake.projectItemsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ProjectItemsCallCount() int {
	fake.projectItemsMutex.RLock()
	defer fake.projectItemsMutex.RUnlock()
	return len(fake.projectItemsArgsForCall)
}

func (fake *FakeClient) ProjectItemsCalls(stub func(context.Context, int) ([]client.ProjectV2ItemWithIssueContent, error)) {
	fake.projectItemsMutex.Lock()
	defer fake.projectItemsMutex.Unlock()
	fake.ProjectItemsStub = stub
}

func (fake *FakeClient) ProjectItemsArgsForCall(i int) (context.Context, int) {
	fake.projectItemsMutex.RLock()
	defer fake.projectItemsMutex.RUnlock()
	argsForCall := fake.projectItemsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ProjectItemsReturns(result1 []client.ProjectV2ItemWithIssueContent, result2 error) {
	fake.projectItemsMutex.Lock()
	defer fake.projectItemsMutex.Unlock()
	fake.ProjectItemsStub = nil
	fake.projectItemsReturns = struct {
		result1 []client.ProjectV2ItemWithIssueContent
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ProjectItemsReturnsOnCall(i int, result1 []client.ProjectV2ItemWithIssueContent, result2 error) {
	fake.projectItemsMutex.Lock()
	defer fake.projectItemsMutex.Unlock()
	fake.ProjectItemsStub = nil
	if fake.projectItemsReturnsOnCall == nil {
		fake.projectItemsReturnsOnCall = make(map[int]struct {
			result1 []client.ProjectV2ItemWithIssueContent
			result2 error
		})
	}
	fake.projectItemsReturnsOnCall[i] = struct {
		result1 []client.ProjectV2ItemWithIssueContent
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PullRequest(arg1 context.Context, arg2 int) (client.PullRequest, error) {
	fake.pullRequestMutex.Lock()
	ret, specificReturn := fake.pullRequestReturnsOnCall[len(fake.pullRequestArgsForCall)]
	fake.pullRequestArgsForCall = append(fake.pullRequestArgsForCall, struct {
		arg1 context.Context
		arg2 int
	}{arg1, arg2})
	stub := fake.PullRequestStub
	fakeReturns := fake.pullRequestReturns
	fake.recordInvocation("PullRequest", []interface{}{arg1, arg2})
	fake.pullRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PullRequestCallCount() int {
	fake.pullRequestMutex.RLock()
	defer fake.pullRequestMutex.RUnlock()
	return len(fake.pullRequestArgsForCall)
}

func (fake *FakeClient) PullRequestCalls(stub func(context.Context, int) (client.PullRequest, error)) {
	fake.pullRequestMutex.Lock()
	defer fake.pullRequestMutex.Unlock()
	fake.PullRequestStub = stub
}

func (fake *FakeClient) PullRequestArgsForCall(i int) (context.Context, int) {
	fake.pullRequestMutex.RLock()
	defer fake.pullRequestMutex.RUnlock()
	argsForCall := fake.pullRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) PullRequestReturns(result1 client.PullRequest, result2 error) {
	fake.pullRequestMutex.Lock()
	defer fake.pullRequestMutex.Unlock()
	fake.PullRequestStub = nil
	fake.pullRequestReturns = struct {
		result1 client.PullRequest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PullRequestReturnsOnCall(i int, result1 client.PullRequest, result2 error) {
	fake.pullRequestMutex.Lock()
	defer fake.pullRequestMutex.Unlock()
	fake.PullRequestStub = nil
	if fake.pullRequestReturnsOnCall == nil {
		fake.pullRequestReturnsOnCall = make(map[int]struct {
			result1 client.PullRequest
			result2 error
		})
	}
	fake.pullRequestReturnsOnCall[i] = struct {
		result1 client.PullRequest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PullRequests(arg1 context.Context) ([]client.PullRequest, error) {
	fake.pullRequestsMutex.Lock()
	ret, specificReturn := fake.pullRequestsReturnsOnCall[len(fake.pullRequestsArgsForCall)]
	fake.pullRequestsArgsForCall = append(fake.pullRequestsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.PullRequestsStub
	fakeReturns := fake.pullRequestsReturns
	fake.recordInvocation("PullRequests", []interface{}{arg1})
	fake.pullRequestsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PullRequestsCallCount() int {
	fake.pullRequestsMutex.RLock()
	defer fake.pullRequestsMutex.RUnlock()
	return len(fake.pullRequestsArgsForCall)
}

func (fake *FakeClient) PullRequestsCalls(stub func(context.Context) ([]client.PullRequest, error)) {
	fake.pullRequestsMutex.Lock()
	defer fake.pullRequestsMutex.Unlock()
	fake.PullRequestsStub = stub
}

func (fake *FakeClient) PullRequestsArgsForCall(i int) context.Context {
	fake.pullRequestsMutex.RLock()
	defer fake.pullRequestsMutex.RUnlock()
	argsForCall := fake.pullRequestsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) PullRequestsReturns(result1 []client.PullRequest, result2 error) {
	fake.pullRequestsMutex.Lock()
	defer fake.pullRequestsMutex.Unlock()
	fake.PullRequestsStub = nil
	fake.pullRequestsReturns = struct {
		result1 []client.PullRequest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PullRequestsReturnsOnCall(i int, result1 []client.PullRequest, result2 error) {
	fake.pullRequestsMutex.Lock()
	defer fake.pullRequestsMutex.Unlock()
	fake.PullRequestsStub = nil
	if fake.pullRequestsReturnsOnCall == nil {
		fake.pullRequestsReturnsOnCall = make(map[int]struct {
			result1 []client.PullRequest
			result2 error
		})
	}
	fake.pullRequestsReturnsOnCall[i] = struct {
		result1 []client.PullRequest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RemoveLabel(arg1 context.Context, arg2 string, arg3 githubv4.ID) error {
	fake.removeLabelMutex.Lock()
	ret, specificReturn := fake.removeLabelReturnsOnCall[len(fake.removeLabelArgsForCall)]
	fake.removeLabelArgsForCall = append(fake.removeLabelArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 githubv4.ID
	}{arg1, arg2, arg3})
	stub := fake.RemoveLabelStub
	fakeReturns := fake.removeLabelReturns
	fake.recordInvocation("RemoveLabel", []interface{}{arg1, arg2, arg3})
	fake.removeLabelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) RemoveLabelCallCount() int {
	fake.removeLabelMutex.RLock()
	defer fake.removeLabelMutex.RUnlock()
	return len(fake.removeLabelArgsForCall)
}

func (fake *FakeClient) RemoveLabelCalls(stub func(context.Context, string, githubv4.ID) error) {
	fake.removeLabelMutex.Lock()
	defer fake.removeLabelMutex.Unlock()
	fake.RemoveLabelStub = stub
}

func (fake *FakeClient) RemoveLabelArgsForCall(i int) (context.Context, string, githubv4.ID) {
	fake.removeLabelMutex.RLock()
	defer fake.removeLabelMutex.RUnlock()
	argsForCall := fake.removeLabelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) RemoveLabelReturns(result1 error) {
	fake.removeLabelMutex.Lock()
	defer fake.removeLabelMutex.Unlock()
	fake.RemoveLabelStub = nil
	fake.removeLabelReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RemoveLabelReturnsOnCall(i int, result1 error) {
	fake.removeLabelMutex.Lock()
	defer fake.removeLabelMutex.Unlock()
	fake.RemoveLabelStub = nil
	if fake.removeLabelReturnsOnCall == nil {
		fake.removeLabelReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeLabelReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UpdateIssueStatus(arg1 context.Context, arg2 client.Issue, arg3 githubv4.String, arg4 int) (bool, error) {
	fake.updateIssueStatusMutex.Lock()
	ret, specificReturn := fake.updateIssueStatusReturnsOnCall[len(fake.updateIssueStatusArgsForCall)]
	fake.updateIssueStatusArgsForCall = append(fake.updateIssueStatusArgsForCall, struct {
		arg1 context.Context
		arg2 client.Issue
		arg3 githubv4.String
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.UpdateIssueStatusStub
	fakeReturns := fake.updateIssueStatusReturns
	fake.recordInvocation("UpdateIssueStatus", []interface{}{arg1, arg2, arg3, arg4})
	fake.updateIssueStatusMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) UpdateIssueStatusCallCount() int {
	fake.updateIssueStatusMutex.RLock()
	defer fake.updateIssueStatusMutex.RUnlock()
	return len(fake.updateIssueStatusArgsForCall)
}

func (fake *FakeClient) UpdateIssueStatusCalls(stub func(context.Context, client.Issue, githubv4.String, int) (bool, error)) {
	fake.updateIssueStatusMutex.Lock()
	defer fake.updateIssueStatusMutex.Unlock()
	fake.UpdateIssueStatusStub = stub
}

func (fake *FakeClient) UpdateIssueStatusArgsForCall(i int) (context.Context, client.Issue, githubv4.String, int) {
	fake.updateIssueStatusMutex.RLock()
	defer fake.updateIssueStatusMutex.RUnlock()
	argsForCall := fake.updateIssueStatusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) UpdateIssueStatusReturns(result1 bool, result2 error) {
	fake.updateIssueStatusMutex.Lock()
	defer fake.updateIssueStatusMutex.Unlock()
	fake.UpdateIssueStatusStub = nil
	fake.updateIssueStatusReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateIssueStatusReturnsOnCall(i int, result1 bool, result2 error) {
	fake.updateIssueStatusMutex.Lock()
	defer fake.updateIssueStatusMutex.Unlock()
	fake.UpdateIssueStatusStub = nil
	if fake.updateIssueStatusReturnsOnCall == nil {
		fake.updateIssueStatusReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.updateIssueStatusReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) User(arg1 context.Context, arg2 string) (client.User, error) {
	fake.userMutex.Lock()
	ret, specificReturn := fake.userReturnsOnCall[len(fake.userArgsForCall)]
	fake.userArgsForCall = append(fake.userArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.UserStub
	fakeReturns := fake.userReturns
	fake.recordInvocation("User", []interface{}{arg1, arg2})
	fake.userMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) UserCallCount() int {
	fake.userMutex.RLock()
	defer fake.userMutex.RUnlock()
	return len(fake.userArgsForCall)
}

func (fake *FakeClient) UserCalls(stub func(context.Context, string) (client.User, error)) {
	fake.userMutex.Lock()
	defer fake.userMutex.Unlock()
	fake.UserStub = stub
}

func (fake *FakeClient) UserArgsForCall(i int) (context.Context, string) {
	fake.userMutex.RLock()
	defer fake.userMutex.RUnlock()
	argsForCall := fake.userArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) UserReturns(result1 client.User, result2 error) {
	fake.userMutex.Lock()
	defer fake.userMutex.Unlock()
	fake.UserStub = nil
	fake.userReturns = struct {
		result1 client.User
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UserReturnsOnCall(i int, result1 client.User, result2 error) {
	fake.userMutex.Lock()
	defer fake.userMutex.Unlock()
	fake.UserStub = nil
	if fake.userReturnsOnCall == nil {
		fake.userReturnsOnCall = make(map[int]struct {
			result1 client.User
			result2 error
		})
	}
	fake.userReturnsOnCall[i] = struct {
		result1 client.User
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addLabelMutex.RLock()
	defer fake.addLabelMutex.RUnlock()
	fake.addReactionMutex.RLock()
	defer fake.addReactionMutex.RUnlock()
	fake.assignIssueToProjectMutex.RLock()
	defer fake.assignIssueToProjectMutex.RUnlock()
	fake.assignUserToAssignableMutex.RLock()
	defer fake.assignUserToAssignableMutex.RUnlock()
	fake.issueMutex.RLock()
	defer fake.issueMutex.RUnlock()
	fake.leaveCommentMutex.RLock()
	defer fake.leaveCommentMutex.RUnlock()
	fake.projectItemsMutex.RLock()
	defer fake.projectItemsMutex.RUnlock()
	fake.pullRequestMutex.RLock()
	defer fake.pullRequestMutex.RUnlock()
	fake.pullRequestsMutex.RLock()
	defer fake.pullRequestsMutex.RUnlock()
	fake.removeLabelMutex.RLock()
	defer fake.removeLabelMutex.RUnlock()
	fake.updateIssueStatusMutex.RLock()
	defer fake.updateIssueStatusMutex.RUnlock()
	fake.userMutex.RLock()
	defer fake.userMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ client.Client = new(FakeClient)
